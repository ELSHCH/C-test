#include <stdio.h>
#include <time.h>
#include <math.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#include "angles.h"
//#include "gribhandler.h"
//#include "make_tm.h"
#include "sphere.h"
#include "randn.h"
#include "gshhs.h"

/*******************************************************************************
 * This is the Leeway model. Search areas for common objects at sea are
 * computed for objects under the influence of wind and surface currents.
 *
 * Introduction
 * A Monte Carlo type ensemble of drifting particles defines the
 * search area for an object with known drift characteristics (leeway
 * coefficients).
 *
 * Leeway formula
 * The advection of the particles follows the linear regression model outlined
 * by Allen and Plourde (1999). A slight modification to the original
 * formulation is that particles are no longer allowed to move upwind. This is
 * of relevance to low-windage categories such as a person in water (PIW) with
 * high standard deviation in their down-wind leeway coefficients.
 *
 * Jibing
 * A very simplistic jibing model is included to account for observed
 * cases of jibing (change of tack). The default probability is 4% per hour
 * (can be change by the user), which is relatively low but still sufficient
 * to influence the shape of the search area over time.
 *
 * Error model of leeway coefficients
 * The uncertainties associated with the leeway coefficients are assumed
 * constant in time, i.e., no one particle changes its drift properties over
 * time, except for a possible change in relative wind direction (jibing). This
 * reflects the uncertainties that stem from the field experiments conducted to
 * establish the drift properties of search objects.
 *
 * Wind and current fields
 * The model requires surface currents and 10m-wind to properly advect the
 * drifting objects. The model reads fields in GRIB format.
 * Currently accepted projections are regular latitude-longitude (plate
 * carree), rotated spherical and the polar stereographic.
 *
 * Error model of wind and current fields
 * The uncertainties in the current and wind fields are of secondary importance
 * to the dispersion of the ensemble because the perturbations are
 * time-varying. A random walk formulation (zeroth order Markov process) is
 * used.
 *
 * Numerical scheme
 * A second-order Runge Kutta scheme is used to advect the particles.
 *
 * Stranding of particles
 * Particles can strand against a GSHHS coastline or the current grid may be
 * used if desired. If a coastline contour is used, the current is
 * extrapolated towards the coast.
 *
 * Preprocessing and input
 * The model requires an input file defining the initial time of release and
 * the position of each particle. The drift properties (leeway coefficients)
 * and the magnitude of the ensemble are also determined by the input file.
 *
 * Output and postprocessing
 * The model outputs data in a self-explanatory ASCII format. Filters exist to
 * convert the output to GrADS binary format and to Matlab structs.
 *
 * Programming convention
 * Local variables are defined throughout the code in blocks enclosed by
 * {braces}. The scope of these local variables is limited to the {enclosing
 * braces}. When such a block occurs it is marked with comments starting with
 * "Block:". This is an alternative to defining functions that are called
 * only once per iteration of the main loop and is merely a matter of taste.
 *
 * References
 * A Allen and J V Plourde, 1999: Review of Leeway: Field Experiments and
 * Implementation, US Coast Guard Tech Rep CG-D-08-99, US Coast Guard R&D
 * Center, 1082 Shennecossett Road, Groton, CT, USA.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Contact information:
 * Norwegian Meteorological Institute
 * P.O. Box 43, Blindern
 * NO-0313 OSLO
 * NORWAY
 * email: oyvind.breivik@met.no or met.inst@met.no (indicate clearly the nature
 * of your request)
 *
 * To compile:
 *
 *  % make all
 *  % make lwseed # seeder
 *  % make leeway # leeway model
 *
 * Usage:
 *
 *  % leeway leeway.in leeway.out
 *
 * Requires:
 *
 *   - Input file leeway.in - generated by e.g. lwseed.c
 *
 *   - gribw - C library developed by Wesley Ebisuzaki @ NOAA, freely available.
 *
 *   - Wind and current in GRIB format.
 *
 * 2006-11-27, oyvind.breivik@met.no
 * 2007-01-30, Minor correction, forcing field time check
 * 2007-04-25, Version 2.4, support for polar stereographic and rot spher added.
 * 2008-05-14, Version 2.5, support for GSHHS coastline database
 ******************************************************************************/

/* Constants */
#define VER 2.5       /* model version */
#define USAGE "\nUsage: %s <leeway.in> <leeway.out>\n\nPreprocess with lwseed\n"
#define DRIFTING 11   /* drifting particles are tagged as 11 */
#define STRANDED 41   /* stranded particles are tagged as 41 */
#define OFFGRID 42    /* distinguish off-grid from stranded */
#define RW 0          /* right-of-wind placeholder for leeway coefficients */
#define LW 1          /* left-of-wind placeholder */
#define DW 2          /* downwind placeholder */
#define MAXLEN 700    /* string length */
#define TIMESTEP 3600  /* default timestep [s] */
#define MAXHOURS 120   /* stop run after MAXHOURS if winds AND curr are const */
#define TOL 1.0e-6    /* a VERY small number */
#define EARTH_R 6356.78   /* Earth Radius */

/* Local functions */
void leeway(float *urel, float *vrel, float uw, float vw, float *lwa, float *lwb, float *lwsd, float rdw, float rcw, int ort);
void stranded_particles(int *stranded, int *offgrid, int *nstranded, int *noffgrid, float *uc, float *uw, int n);
void offgrid_particles(int *stranded, int *offgrid, int *nstranded, int *noffgrid, float *uc, float *uw, int n);
void intersect_coastline(int *stranded, int *nstranded, GSHHSIntersect *inter, float *oldlon, float *oldlat, float *newlon, float *newlat, int n);
void printout(FILE *fout, time_t now, int istepout, int outputinterval, int n, int nold, int nmem, float meanlon, float meanlat, float *lon, float *lat, int *state, int *stranded, int *birth, int *ort);
void meanposition(float *meanlon, float *meanlat, float *lon, float *lat, int n);
void printout_traj(FILE *fout_traj,int n,int istepout,int *ind,float *lon, float *lat, int *state,int *stranded, int *birth, int *ort);
void printout_vel(FILE *fout_vel,int n,int istepout, int *ind,float *uvdrift, float *vvdrift, int *state,int *stranded, int *birth, int *ort);
void printout_mean(FILE *fout_mean,int istepout,int outputinterval,int n,int nold,float meanlon,float meanlat);
/*void printout_traj(FILE *fout_traj,int n,float *lon, float *lat, int *state,int *stranded, time_t *birth, int *ort); */
void regionQuery(float EPS_CLUSTER1, int n,float *p_s,float *v_s,float *traj_lon,float *traj_lat,float *velu,float *velv,int *num_Pts_s,int *ind_neighbors);
void expandCluster(float EPS_CLUSTER1,int NMINPOINTS,int n,int *n_cluster,int *num_point_neighbors,int ind_p,float *traj_lon,float *traj_lat,float *vel_u,float *vel_v,int *intPts,int *cls);
void printout_traj_cluster(FILE *fout_cluster_mean,int n,int num_clusters,int *num_points_Cl,float *lon, float *lat, int *cl,int sstep);
/*void printout_traj_final(FILE *fout_final,FILE *fout_traj,int *cl, int n);*/
void compute_cluster(float EPS_CLUSTER1,int NMINPOINTS,int n,int *num_clusters,int *num_points_Cl,float ind_lon,float ind_lat,float *final_lon, float *final_lat, float *velu,float *velv,int *clu);
void compute_distr(FILE *fout_distr,int n,float *lon,float *lat,float *distr_lon,float *distr_lat,float *distrln,float *distrlt);
void maxmin_array(int n, float *array, float *max_array,float *min_array);
void inter_distr(FILE *fout_interdist,int n,float *lon,float *lat,float *uvdrift, float *vvdrift, float *mean_dist,float *mean_dist_vel);
void inter_time(int n, float weigth, float *uold, float *vold, float *unew, float *vnew, float *v_x, float *v_y);
void bilin(int numt, int n,int dimx, int dimy,float *lon, float *lat,float coordx[dimx][dimy], float coordy[dimx][dimy], float ***ucnew, float ***vcnew, float *uc, float *vc);
void swapfields(int numt,int dimx, int dimy, float ***ucold, float ***ucnew, float ***vcold, float ***vcnew);
void IsOnOffLand(int k,int *flag_i, int DIMX_C, int DIMY_C,int onland[DIMX_C][DIMY_C],float ln,float lt, float maplon[DIMX_C], float maplat[DIMY_C]);
/********************************* MAIN ****************************************/

int main(int argc, char **argv) {

 /*
  * Pointers to GRIB structs
  *
  *  The structs contain a 2D array of vector components in a grid
  *  derived from a GRIB file along with information on the
  *  forecast time, dimensions, resolution, and physical boundaries of the
  *  grid.
  *
  *  See gribhandler.h for a detailed explanation.
  *
  */

  /* GSHHS coastline struct */
 // printf("%d\n",MAX_NB_OBJ);
 //  GSHHS List[MAX_NB_OBJ];
     GSHHS List[1000];
     GSHHSIntersect inter;
     int SizeList=0;


 /*
  * Arrays [nmem]
  *
  *  Arrays of length nmem contain information about the individual ensemble
  *  members.
  *
  */

   float *lon, *lat;      /* particle position [deg] */
   float *distr_lon, *distr_lat,*distrln,*distrlt;
   float interdist=0;     /* particle position [deg] */
   float intervel=0;     /* particle position [deg] */
   float *oldlon, *oldlat;/* old particle position [deg] */
   float *lon1, *lat1;    /* intermediate particle position [deg] */
   int *birth;         /* particle release time [s from start t0] */
   float *uc, *vc, *uc_d, *vc_d,*uw_d, *vw_d;        /* east- and north-components of current in particle positions */
   float *uvdrift,*vvdrift; /*components of wind and current velocities*/
   float *ucpert, *vcpert;/* current perturbations */
   float *norm_vel_x, *norm_vel_y;/* current perturbations */
   float *uw, *vw;        /* east- and north-components of wind in particle positions */
   float *uwpert, *vwpert;/* wind perturbations */
   float *rdw, *rcw;      /* random perturbations downwind & crosswind */
   int *ort;              /* orientation of particle */
   int *cl;              /* assignment of cluster for a particle */
   int *stranded, *state; /* stranded (logical), state (drifting or stranded) */
   int *offgrid;          /* particle off grid (logical) */

   float *u1, *u2, *v1, *v2; /* work arrays */


 /* Leeway parameters */

   float lwsd[3], lwa[3], lwb[3];
   float pjibe; /* hourly probability of jibing */


 /* Strings */

   char line[MAXLEN];
   char idtag[MAXLEN]; /* arbitrary simulation identifier */


 /* Temporal variables */

   int t = 0;
  // time_t t0, t1;
   int t0, t1;
   int dt = TIMESTEP;
   int tcold=-1, tcnew=-1, twold=-1, twnew=-1;
   struct tm *ptm;    /* pointer to time-struct */
   int yyyy0, mm0, dd0, hh0, mi0, yyyy1, mm1, dd1, hh1, mi1, ss1,ind1;

   /* Temporal weight between old and new field for time interpolation */
   float weight;

   /* System time, for seeding the random number generator.
      Variable also used for output time */
   time_t now;


 /* Wind and current error statistics */

   float ucsd, vcsd; /* std dev of east & north current comp */
   float uwsd, vwsd; /* ditto for wind */
   float ucts, vcts; /* timescale of curr fluctuations (not in use yet) */
   float uwts, vwts; /* ditto for wind (not in use yet) */


 /* Mean longitude and latitude of ensemble */

   float meanlon, meanlat;


 /* Various */

   int nmem;                /* magnitude of ensemble */
   int eot=0;               /* logical: true if end of simulation */
   int k,i,k1,j;
   int *ttstep;                  /*pointer to counter */
   int istep=0, istepout=0; /* counters: timesteps and output timesteps */
   int n=0, nold;           /* counters: seeded particles */
   int seedrate, seedsteps,sumCl;
   int seedduration;        /* duration of seeding [min] */

   int outputinterval;      /* output time interval [s] */
   int nstranded=0, noffgrid=0; /* counters: particles stranded and off grid */
   int idum;                /* dummy variable */

   int constwind=0, constcurr=0; /* logical: true if constant wind or current */
   float uc0=0.0, vc0=0.0;  /* constant current vector */
   float uw0=0.0, vw0=0.0;  /* ditto for wind */
   int nostrand;            /* do particles strand? false=0 */
   int hascoastline=0;      /* coastline database? false=0 */
   float eps, rnd;          /* random number */
   float EPS_CLUSTER1,EPS_CLUSTER2; /*EPS_CLUSTER1  minimum distance between points in cluster */
   float ind_lat,ind_lon; /* minimum distance between points in cluster */
   int NMINPOINTS;      /* minimum number of drifters in cluster */
   int *ind,*num_points_Cl,number_Cl=0;
   float *percent_points;
     int flag_i;
 //  float sum_lon[nmem],sum_lat[nmem],mean_traj_lat[nmem],mean_traj_lon[nmem];
 /* File related vars */

   FILE *currin=NULL, *windin=NULL, *coastin=NULL, *seedin, *fout, *fout_traj,*fout_vel, *mapin, *mapin1,\
    *fout_mean, *fout_final, *fout_distr,*fout_interdist,\
    *fout_final_traj,*fin_curr, *fin_wind;
   char coastfile[MAXLEN]; // GSHHS coastline database
   long cpos=0L, wpos=0L; /* GRIB file position placeholders */
   long filepos;          /* output file position placeholder */
   int err;
   int DIMX_C=97, DIMY_C=97, DIMT_C=59 , DIMX_W=11, DIMY_W=11, DIMT_W=237;

 /* Seed random number generator with current calendar time (epoch seconds from
  * 1970-01-01T00:00:00 UTC) */

   now = time(NULL);
   srand(((unsigned) now)+1); /* add one unit to distinguish from seed.c */


 /* Help line */

   if (argc == 1) {
      fprintf(stderr, "leeway.c, version %g\n", VER);
      fprintf(stderr, USAGE, argv[0]);
      exit(8);
   }


 /* Open input and output files */

   if (argc < 4) {
      fprintf(stderr, USAGE, argv[0]);
      exit(1);
   }
   if ((seedin = fopen(argv[1],"r")) == NULL) {
      fprintf(stderr,"Could not open file: %s\n", argv[1]);
      exit(1);
   }
   if ((fout = fopen(argv[2],"w+")) == NULL) {
      fprintf(stderr,"Could not open file: %s\n", argv[2]);
      exit(1);
   }


 /* Block: Read header from file seedin, write file header to new file fout ****
  *
  *  The seed file is generated by the preprocessing software lwseed and
  *  contains the initial positions of the ensemble members to be advected.
  *  The file also conatins the drift properties and information about the
  *  forcing fields (in GRIB format). This file may be edited manually
  *  if desired.
  *
  */


  /* Block vars */

   /* Search object name */
   char objectname[MAXLEN]; /* object class name, e.g. PIW-1 */
   int objtypeno;           /* object class number */

   /* Simulation date, provided by the seed preprocessor */
   int truedate[6];

   /* "Seed area" or initial distribution of particles is defined by a start
    * position and radius of uncertainty and an end position and radius.
    * This is not strictly necessary any longer as an arbitrary initial
    * distribution may now be defined with a used defined seed preprocessor.
    * The seed preprocessor provided with this code still uses said
    * parameters to define the initial distribution. */
   float startlon, startlat, startrad, endlon, endlat, endrad;
   float ver; /* Code version control */


  /* Read seed file header from file seedin. */

   /* Simulation date, time [UTC] & id tag */
   fgets(line, MAXLEN, seedin);    /* line 1 - ignore */
   fgets(line, MAXLEN, seedin);        /*  2 - ignore */
   fgets(line, MAXLEN, seedin);        /*  3 - true date */
   sscanf(line, "%4d%*c%2d%*c%2d%*c%2d%*c%2d%*c%d%*c%d%*c%s",&truedate[0],\
    &truedate[1],&truedate[2],&truedate[3],&truedate[4],&truedate[5],\
    &outputinterval,idtag);
   /* Check consistency between model timestep and output timestep
      If inconsistent, set model timestep to coincide with output timestep
    */

  outputinterval = 10*outputinterval;
   /*if ( (outputinterval < dt) || ((outputinterval)%dt != 0) ) {
      dt = outputinterval;
   } */

  /* Code version, no-strand option and optional coastline database */
   fgets(line, MAXLEN, seedin);        /*  4 - ignore */
   fgets(line, MAXLEN, seedin);        /*  5 - ignore */
   fgets(line, MAXLEN, seedin);        /*  6 - model version, no strand & coastline */
//   sscanf(line, "%g%*c%d%*c%s", &ver, &nostrand, coastfile);
//   if (fabsf(ver-VER)>TOL) {
//      fprintf(stderr, "Error: unknown input file %s, version %5.2f\n", argv[1],
//            ver);
//      fprintf(stderr, "LEEWAY version %5.2f\n", VER);
//      exit(1);
//   } // endif
//   printf("%s\n","print");

 //  char mapfile[] = "/cygdrive/e/ChapterMed/Winter/mapregion.txt";
   char mapfile[] = "C:/cygwin/home/shchekin/Documents/ChapterMed/WasteSim/Summer2013/mapregion.txt";
   mapin = fopen(mapfile,"r");
   char mapfile1[] = "C:/cygwin/home/shchekin/Documents/ChapterMed/WasteSim/Summer2013/mapregion1.txt";
   mapin1 = fopen(mapfile1,"w");

   int onland[DIMY_C][DIMX_C];
   int ud;
   float la, lo, lonmap[DIMX_C], latmap[DIMY_C];
   for (i=0;i<DIMX_C;i++){
    for (j=0;j<DIMY_C;j++) {
        fscanf(mapin,"%d\t%g\t%g\n",&ud,&lo, &la);
        onland[j][i]=ud;
        lonmap[i]=lo;
        latmap[j]=la;
        fprintf(mapin1,"%g\t%g\t%d\n",lonmap[i],latmap[j],onland[j][i]);
  //      if (onland[i][j]==1) {
  //          printf("%d\n",onland[i][j]);
  //      }
    }
   }
  // fclose(mapin1);
//    for (i=0;i<DIMX_C;i++){
//    for (j=0;j<DIMY_C;j++) {
//        printf("%d\t%g\t%g\n",j+i*DIMY_C,lonmap[i],latmap[j]);
      //  printf(mapin1,"%d\n",onland[i][j]);
  //      if (onland[i][j]==1) {
  //          printf("%d\n",onland[i][j]);
  //      }
 //   }
 //  }
////   if (strncmp(coastfile,"nocoastline",11)!=0) {
////      hascoastline=1;
////      // Initialise GSHHS
////      if ( (coastin = fopen(coastfile, "r" )) == NULL ) {
////         fprintf(stderr, "Error opening GSHHS file %-50s\n",coastfile);
////         exit(1);
////      }
////      gshhs_init(coastin,List,&SizeList,&inter);
////      printf(" Coastline GSHHS file: %-50s\n",coastfile);
////      printf(" Coastline boundaries: west: %g, south: %g, east: %g, north: %g\n",\
////       (float) inter.mMinX/MICRO_SCALE,(float) inter.mMinY/MICRO_SCALE,(float) inter.mMaxX/MICRO_SCALE,\
////       (float) inter.mMaxY/MICRO_SCALE);
////   }
////   else {
////      hascoastline=0;
////      printf(" No coastline GSHHS file %s\n",coastfile);
////   } // endif
////   printf("%s\n","print");
//   /*Open two data files: "leeway_traj.dat" for ensemble trajectories and "leeway_mean.dat" for mean trajectories output*/
//
//printf("%s\n","print");

     char c_num[3];

//     fgets(line, MAXLEN, filein);
//     sscanf(line, "%d\n",&rec_trained_number);
//     fgets(line, MAXLEN, filein);
//     sscanf(line, "%d",&rec_test_number);
     sprintf(c_num, "%s", argv[3]);

     //sprintf(c_train, "%d", rec_trained_number);
     //sprintf(c_test, "%d",rec_test_number);

   //  char name_file_data[] = "C:/Users/shchekin/Documents/ElenaDocuments/InclinationAnalysis/InclinationAlgorithm/recession";
   //  char name_file_opt_parameter[] = "C:/Users/shchekin/Documents/ElenaDocuments/InclinationAnalysis/InclinationAlgorithm/optimal_parameters_";
   //  char name_file_data[] = "C:/Users/ElenaSH/Current_docs/InclinationAnalysis/InclinationAlgorithm/InclinationAlgorithm/recession";
     char name_file_traj[] = "leeway_traj_";

     strcat(name_file_traj, c_num);
     strcat(name_file_traj, ".dat");
      printf("%s\n",name_file_traj);

     fout_traj=fopen(name_file_traj,"w+");

     char name_file_vel[] = "leeway_vel_";

     sprintf(c_num, "%s", argv[3]);

     strcat(name_file_vel, c_num);
     strcat(name_file_vel, ".dat");

     fout_vel=fopen(name_file_vel,"w+");

     char name_file_mean[] = "leeway_mean_";
     sprintf(c_num, "%s", argv[3]);

     strcat(name_file_mean, c_num);
     strcat(name_file_mean, ".dat");

     fout_mean=fopen(name_file_mean,"w+");

     char name_file_traj_final[] = "leeway_traj_final_";
     sprintf(c_num, "%s", argv[3]);

     strcat(name_file_traj_final, c_num);
     strcat(name_file_traj_final, ".dat");

     fout_final=fopen(name_file_traj_final,"w+");

     char name_traj_final_pos[] = "leeway_final_position_";
     sprintf(c_num, "%s", argv[3]);

     strcat(name_traj_final_pos, c_num);
     strcat(name_traj_final_pos, ".dat");

     fout_final_traj=fopen(name_traj_final_pos,"w+");

     char name_file_distr[] = "distr_latlon_";
     sprintf(c_num, "%s", argv[3]);

     strcat(name_file_distr, c_num);
     strcat(name_file_distr, ".dat");

     fout_distr=fopen(name_file_distr,"w+");

      char name_interdist[] = "interdist_";
     sprintf(c_num, "%s", argv[3]);

     strcat(name_interdist, c_num);
     strcat(name_interdist, ".dat");

     fout_interdist=fopen(name_interdist,"w+");

   /* Object class id & name */
   fgets(line, MAXLEN, seedin);        /*  7 - ignore */
   fgets(line, MAXLEN, seedin);        /*  8 - ignore */
   fgets(line, MAXLEN, seedin);        /*  9 - object class id & name */
   sscanf(line, "%d%s", &objtypeno, objectname);

   /* Seeding start time, position & radius */
   fgets(line, MAXLEN, seedin);        /* 10 - ignore */
   fgets(line, MAXLEN, seedin);        /* 11 - ignore */
   fgets(line, MAXLEN, seedin);        /* 12 */
   sscanf(line, "%4d%*c%2d%*c%2d%2d%*c%2d%*c%*2d%g%g%g",&yyyy0,\
      &mm0,&dd0,&hh0,&mi0,&startlon,&startlat,&startrad);

   /* Seeding end time, position & radius */
   fgets(line, MAXLEN, seedin);        /* 13 - ignore */
   fgets(line, MAXLEN, seedin);        /* 14 - ignore */
   fgets(line, MAXLEN, seedin);        /* 15 */
   sscanf(line, "%4d%*c%2d%*c%2d%2d%*c%2d%*c%*2d%g%g%g",&yyyy1,\
      &mm1,&dd1,&hh1,&mi1,&endlon,&endlat,&endrad);

   /* Total no of seeded particles */
   fgets(line, MAXLEN, seedin);        /* 16 - ignore */
   fgets(line, MAXLEN, seedin);        /* 17 - ignore */
   fgets(line, MAXLEN, seedin);        /* 18 */
   sscanf(line, "%d", &nmem);

   /* Right leeway coeffs; slope [%], offset [cm/s], std dev [cm/s] */
   fgets(line, MAXLEN, seedin);        /* 19 - ignore */
   fgets(line, MAXLEN, seedin);        /* 20 - ignore */
   fgets(line, MAXLEN, seedin);        /* 21 */
   sscanf(line, "%g%g%g", &lwa[RW], &lwb[RW], &lwsd[RW]);

   /* Left leeway coeffs; slope [%], offset [cm/s], std dev [cm/s] */
   fgets(line, MAXLEN, seedin);        /* 22 - ignore */
   fgets(line, MAXLEN, seedin);        /* 23 - ignore */
   fgets(line, MAXLEN, seedin);        /* 24 */
   sscanf(line, "%g%g%g", &lwa[LW], &lwb[LW], &lwsd[LW]);

   /* Downwind leeway coeffs; slope [%], offset [cm/s], std dev [cm/s] */
   fgets(line, MAXLEN, seedin);        /* 25 - ignore */
   fgets(line, MAXLEN, seedin);        /* 26 - ignore */
   fgets(line, MAXLEN, seedin);        /* 27 */
   sscanf(line, "%g%g%g", &lwa[DW], &lwb[DW], &lwsd[DW]);

   /* Hourly probability of jibing [%/h] */
   fgets(line, MAXLEN, seedin);        /* 28 - ignore */
   fgets(line, MAXLEN, seedin);        /* 29 - ignore */
   fgets(line, MAXLEN, seedin);        /* 30 */
   sscanf(line, "%g", &pjibe);
   pjibe=pjibe/100.0;                  /* Convert from % to probability */

   /* Wind stats; east & north std dev; east & north integral time scale */
   fgets(line, MAXLEN, seedin);        /* 31 - ignore */
   fgets(line, MAXLEN, seedin);        /* 32 - ignore */
   fgets(line, MAXLEN, seedin);        /* 33 */
   sscanf(line, "%g%g%g%g", &uwsd, &vwsd, &uwts, &vwts);

   /* Current stats; east & north std dev; east & north integral time scale */
   fgets(line, MAXLEN, seedin);        /* 34 - ignore */
   fgets(line, MAXLEN, seedin);        /* 35 - ignore */
   fgets(line, MAXLEN, seedin);        /* 36 */
   sscanf(line, "%g%g%g%g", &ucsd, &vcsd, &ucts, &vcts);
  // printf("%g%g%g%g", ucsd, vcsd, ucts, vcts);

   /* Wind file [GRIB] */
   fgets(line, MAXLEN, seedin);        /* 37 - ignore */
   fgets(line, MAXLEN, seedin);        /* 38 - ignore */
   fgets(line, MAXLEN, seedin);        /* 39 */
  // strncpy(windfile, line, MAXLEN);

   /* Current file [GRIB] */
   fgets(line, MAXLEN, seedin);        /* 40 - ignore */
   fgets(line, MAXLEN, seedin);        /* 41 - ignore */
   fgets(line, MAXLEN, seedin);        /* 42 */
  // strncpy(currfile, line, MAXLEN);

/* Minimal number of drifters in cluster */
   fgets(line, MAXLEN, seedin);        /* 43 - ignore */
   fgets(line, MAXLEN, seedin);        /* 44 - ignore */
   fgets(line, MAXLEN, seedin);        /* 45 - ignore */
   sscanf(line, "%d", &NMINPOINTS);

   fgets(line, MAXLEN, seedin);        /* 49 - ignore */
   fgets(line, MAXLEN, seedin);        /* 50 - ignore */
   fgets(line, MAXLEN, seedin);        /* 51 - ignore */

   time_t rawtime;
   struct tm info;

   time ( &rawtime );
   //info = localtime ( &rawtime );
   info.tm_year = yyyy0 - 1900;
   info.tm_mon = mm0 - 1;
   info.tm_mday = dd0;
   info.tm_hour = hh0;
   info.tm_min = mi0;
   info.tm_sec = 0;
   info.tm_isdst = -1;

   //t0 = mktime(&info); /* start time */
   int cn;
   cn=atoi(c_num);
   t0=24*cn*3600;
   int tend=t0+30*24*3600;
  // ptm = gmtime(&t0);
  // now = t0;

   time ( &rawtime );
   //info = localtime ( &rawtime );
   info.tm_year = yyyy1 - 1900;
   info.tm_mon = mm1 - 1;
   info.tm_mday = dd1;
   info.tm_hour = hh1;
   info.tm_min = mi1;
   info.tm_sec = 0;
   info.tm_isdst = -1;

 //  t1 = mktime(&info); /* start time */
   t1=t0+24*3600;

  /* seedduration = (int) (((float)(t1-t0))/60.0);  seed duration [min]  forward trajectory */
   seedduration = (int) (((float)(t1-t0))); /* seed duration [sec]  */
   seedsteps = (seedduration)/outputinterval; /* number of output intervals seeded over */
   printf("%d\n",seedsteps);
   if (seedsteps < 1) seedsteps=1; /* instantaneous release? */
   seedrate = (int) ((float)nmem/(float)seedsteps+0.5);

   float *** ucold = (float ***)malloc(DIMX_C*sizeof(float**)),\
         *** vcold = (float ***)malloc(DIMX_C*sizeof(float**)), \
         *** ucnew = (float ***)malloc(DIMX_C*sizeof(float**)), \
         *** vcnew = (float ***)malloc(DIMX_C*sizeof(float**));

        for (i = 0; i< DIMX_C; i++) {

         ucold[i] = (float **) malloc(DIMY_C*sizeof(float *));
         vcold[i] = (float **) malloc(DIMY_C*sizeof(float *));
         ucnew[i] = (float **) malloc(DIMY_C*sizeof(float *));
         vcnew[i] = (float **) malloc(DIMY_C*sizeof(float *));

          for (j = 0; j < DIMY_C; j++) {

              ucold[i][j] = (float *)malloc(DIMT_C*sizeof(float));
              vcold[i][j] = (float *)malloc(DIMT_C*sizeof(float));
              ucnew[i][j] = (float *)malloc(DIMT_C*sizeof(float));
              vcnew[i][j] = (float *)malloc(DIMT_C*sizeof(float));
          }

        }
    int t_curr[DIMT_C];
    float lon_curr[DIMX_C][DIMY_C],lat_curr[DIMX_C][DIMY_C];
    int t_wind[DIMT_W];
    float lon_wind[DIMX_W][DIMY_W],lat_wind[DIMX_W][DIMY_W];
    float *** uwold = (float ***)malloc(DIMX_W*sizeof(float**)),\
         *** vwold = (float ***)malloc(DIMX_W*sizeof(float**)), \
         *** uwnew = (float ***)malloc(DIMX_W*sizeof(float**)), \
         *** vwnew = (float ***)malloc(DIMX_W*sizeof(float**));

        for (i = 0; i< DIMX_W; i++) {

         uwold[i] = (float **) malloc(DIMY_W*sizeof(float *));
         vwold[i] = (float **) malloc(DIMY_W*sizeof(float *));
         uwnew[i] = (float **) malloc(DIMY_W*sizeof(float *));
         vwnew[i] = (float **) malloc(DIMY_W*sizeof(float *));

          for (j = 0; j < DIMY_W; j++) {

              uwold[i][j] = (float *)malloc(DIMT_W*sizeof(float));
              vwold[i][j] = (float *)malloc(DIMT_W*sizeof(float));
              uwnew[i][j] = (float *)malloc(DIMT_W*sizeof(float));
              vwnew[i][j] = (float *)malloc(DIMT_W*sizeof(float));
          }

        }

   float loc, lac;
   int tc;
   char currfile[] = "C:/cygwin/home/shchekin/Documents/ChapterMed/HighWindage/Winter2014/mean_Wc2014_2";
  // char currfile[] = "/cygdrive/e/ChapterMed/Winter/mean_Wc2013_2016_2";
   currin = fopen(currfile,"r");

   printf("%s\n",currfile);
   char windfile[] = "C:/cygwin/home/shchekin/Documents/ChapterMed/HighWindage/Winter2014/mean_Ww2014.txt";
  // char windfile[] = "/cygdrive/e/ChapterMed/Winter/mean_Ww2013_2016.txt";
   windin = fopen(windfile,"r");
   //fscanf(currin,"%g\t%g\t%d\t%g\t%g\n",&uc,&vc,&tc,&loc,&lac);
   float ucc, vcc;
   for (k=0;k<DIMT_C;k++) {
    for (i=0;i<DIMX_C;i++) {
        for (j=0;j<DIMY_C;j++) {
            fscanf(currin,"%g\t%g\t%d\t%g\t%g\n",&ucc,&vcc,&tc,&loc,&lac);
       //     fscanf(currfile,"%g\t%g\t%d\t%g\t%g\n",
            ucold[i][j][k]=ucc;
            vcold[i][j][k]=vcc;
            t_curr[k]=tc*3600;
            lon_curr[i][j]=loc;
            lat_curr[i][j]=lac;
       //     printf("%g\n",lat_curr[i][j]);
      //      printf("%g\t%g\t%d\t%g\t%g\n",ucold[i][j][k],vcold[i][j][k],t_curr[k],lon_curr[i][j],lat_curr[i][j]);
        }
    }
   }

   for (i=0;i<DIMX_W;i++) {
        for (j=0;j<DIMY_W;j++) {
          for (k=0;k<DIMT_W;k++) {
            fscanf(windin,"%g\t%g\t%d\t%g\t%g\n",&ucc,&vcc,&tc,&loc,&lac);
       //     fscanf(currfile,"%g\t%g\t%d\t%g\t%g\n",
            uwold[i][j][k]=ucc;
            vwold[i][j][k]=vcc;
            t_wind[k]=6*k*3600;
            lon_wind[i][j]=loc;
            lat_wind[i][j]=lac;
       //     printf("%g\n",lat_curr[i][j]);
       //     printf("%g\t%g\t%d\t%g\t%g\n",uwold[i][j][k],vwold[i][j][k],t_wind[k],lon_wind[i][j],lat_wind[i][j]);
        }
    }
   }
//    for (k=0;k<DIMT_W;k++){
//    printf("%d\n",t_wind[k]);
//   }

//   }
  /* Write header to file fout */

   fprintf(fout, "# Drift simulation initiated [UTC]:\n");
   fprintf(fout, "simDate\tsimTime\n");
   fprintf(fout, "%4d-%02d-%02d\t%02d:%02d:%02d\t%s\n",\
      truedate[0], truedate[1], truedate[2],\
      truedate[3], truedate[4], truedate[5],\
      idtag);

   fprintf(fout, "# Model version:\n");
   fprintf(fout, "modelVersion\n");
   fprintf(fout, "%5.2f\n", VER);

   fprintf(fout, "# Object class id & name:\n");
   fprintf(fout, "objectClassId\tobjectClassName\n");
   fprintf(fout, "%3d\t%s\n", objtypeno, objectname);

   fprintf(fout, "# Seeding start time, position & radius:\n");
   fprintf(fout, "startDate\tstartTime\tstartLon\tstartLat\tstartRad\n");
   fprintf(fout, "%4d-%02d-%02d\t%02d:%02d:%02d\t%9.4f\t%8.4f\t%9.3f\n",\
      yyyy0, mm0, dd0, hh0, mi0, 0, startlon, startlat, startrad);

   fprintf(fout, "# Seeding end time, position & radius:\n");
   fprintf(fout, "endDate\tendTime\tendLon\tendLat\tendRad\n");
   fprintf(fout, "%4d-%02d-%02d\t%02d:%02d:%02d\t%9.4f\t%8.4f\t%9.3f\n",\
      yyyy1, mm1, dd1, hh1, mi1, 0, endlon, endlat, endrad);

   fprintf(fout, "# Duration of seeding [min] & [timesteps]:\n");
   fprintf(fout, "seedDuration\tseedSteps\n");
   fprintf(fout, "%6d\t%5d\n", seedduration, seedsteps);

   fprintf(fout, "# Length of timestep [min]:\n");
   fprintf(fout, "timeStep\n");
   fprintf(fout, "%6d\n", outputinterval);

   /* Temporary, to be filled in at the end of the simulation */
   fprintf(fout, "# Length of model simulation [min] & [timesteps]:\n");
   fprintf(fout, "simLength\tsimSteps\n");
   fprintf(fout, "xxxxxx\tyyyyy\n");
   filepos = ftell(fout);

   fprintf(fout, "# Total no of seeded particles:\n");
   fprintf(fout, "seedTotal\n");
   fprintf(fout, "%4d\n", nmem);

   fprintf(fout, "# Particles seeded per timestep:\n");
   fprintf(fout, "seedRate\n");
   fprintf(fout, "%4d\n", seedrate);

   /* Print start date to stdout */
   printf("\nLeeway starts. First date  %4d-%02d-%02dT%02d:%02d:%02d UTC\n",
      yyyy0, mm0, dd0, hh0, mi0, 0);

  /* end block: read & write header ******************************************/


 /* Size up arrays [nmem] for holding particle information.
  * This must be done after reading the magnitude of the ensemble, nmem, from
  * file seedin. */

   lon =    (float *)    malloc(nmem * sizeof(float));
   lat =    (float *)    malloc(nmem * sizeof(float));
   distr_lat =    (float *)    malloc(nmem * sizeof(float));
   distr_lon =    (float *)    malloc(nmem * sizeof(float));
   distrlt =    (float *)    malloc(150 * sizeof(float));
   distrln =    (float *)    malloc(150 * sizeof(float));
   lat =    (float *)    malloc(nmem * sizeof(float));
   uvdrift =    (float *)    malloc(nmem * sizeof(float));
   norm_vel_x =    (float *)    malloc(nmem * sizeof(float));
   vvdrift =    (float *)    malloc(nmem * sizeof(float));
   norm_vel_y =    (float *)    malloc(nmem * sizeof(float));
   lon1 =   (float *)    malloc(nmem * sizeof(float));
   lat1 =   (float *)    malloc(nmem * sizeof(float));
   oldlon = (float *)    malloc(nmem * sizeof(float));
   oldlat = (float *)    malloc(nmem * sizeof(float));
   uc =     (float *)    malloc(nmem * sizeof(float));
   vc =     (float *)    malloc(nmem * sizeof(float));
   ucpert = (float *)    malloc(nmem * sizeof(float));
   vcpert = (float *)    malloc(nmem * sizeof(float));
   uw =     (float *)    malloc(nmem * sizeof(float));
   vw =     (float *)    malloc(nmem * sizeof(float));
   uwpert = (float *)    malloc(nmem * sizeof(float));
   vwpert = (float *)    malloc(nmem * sizeof(float));
   rdw =    (float *)    malloc(nmem * sizeof(float));
   rcw =    (float *)    malloc(nmem * sizeof(float));
   birth =    (int *) malloc(nmem * sizeof(int));
   ort =      (int *)    malloc(nmem * sizeof(int));
   ind =      (int *)    malloc(nmem * sizeof(int));
   state =    (int *)    malloc(nmem * sizeof(int));
   stranded = (int *)    malloc(nmem * sizeof(int));
   offgrid =  (int *)    malloc(nmem * sizeof(int));
   cl =  (int *)    malloc(nmem * sizeof(int));
   num_points_Cl =  (int *)    malloc(nmem * sizeof(int));
   percent_points =  (float *)  malloc(nmem * sizeof(float));

   /* Work arrays */
   u1 = (float *) malloc(nmem * sizeof(float));
   v1 = (float *) malloc(nmem * sizeof(float));
   u2 = (float *) malloc(nmem * sizeof(float));
   v2 = (float *) malloc(nmem * sizeof(float));
   uc_d =    (float *)    malloc(nmem * sizeof(float));
   vc_d =    (float *)    malloc(nmem * sizeof(float));
   uw_d =    (float *)    malloc(nmem * sizeof(float));
   vw_d =    (float *)    malloc(nmem * sizeof(float));

// /* Use constant current instead of GRIB file?
//  * By editing line 42 of file seedin, a constant current vector can be used
//  * instead of GRIB data. Example:
//  * constant 0.5 0.0
//  * tells leeway to assume a constant current of 0.5 m/s in eastward direction.
//  */
//   if (!strncmp(currfile, "constant", 8)) {
//
//      /* constcurr: true when current is constant and not read from GRIB file */
//      constcurr = 1;
//
//      sscanf(currfile, "%*s%g%g",&uc0,&vc0);
//      /* Loop over all particles and set constant curr vector */
//      for (k=0; k<nmem; k++) {
//         uc[k] = uc0;
//         vc[k] = vc0;
//      } /* end for */
//      printf(" Constant current vector (%.2f, %.2f) m/s\n", uc0, vc0);
//   }
//
//  /* Else open curr file & read first fields */
//   else {
//
//     /* constcurr: false when current is read from GRIB file */
//      constcurr = 0;
//
//      sscanf(currfile,"%s",line);
//      if ((currin = fopen(line,"rb")) == NULL) {
//         fprintf(stderr, "Could not open file: %s\n", currfile);
//         exit(1);
//      }
//      printf(" Current vector GRIB file: %-50s\n", currfile);
//
//     /* Read first two current fields from file */
//      readgrib(ucold, currin, &cpos); /* u-component [m/s] */
//      readgrib(vcold, currin, &cpos); /* v-component */
        tcold = t_curr[0];
//      readgrib(ucnew, currin, &cpos);
//      readgrib(vcnew, currin, &cpos);
        tcnew = t_curr[1];
//      printf (" Curr grid: nx=%d, ny=%d\n", ucnew->nx,ucnew->ny);
//
     /* Check that first current field is prior to start of simulation */
      if (t0 < tcold) {
         fprintf(stderr, "Error: No valid current field found, start time too early\n");
         exit(1);
      }
 //  } /* end if (constant current) */


//// /* Use constant wind instead of GRIB file?
////  * By editing line 39 of file seedin, a constant wind vector can be used,
////  * similar to the current vector described above.
////  */
////
////   if (!strncmp(windfile, "constant", 8)) {
////
////     /* constwind: true when wind is constant and not read from GRIB file */
////      constwind = 1;
////
////      sscanf(windfile, "%*s%g%g",&uw0,&vw0);
////
////     /* Loop over all particles and set constant wind vector */
////      for (k=0; k<nmem; k++) {
////         uw[k] = uw0;
////         vw[k] = vw0;
////         cl[k]=0;
////      } /* end for */
////      printf(" Constant wind vector (%.2f, %.2f) m/s\n", uw0, vw0);
////   }
////
////  /* Else open wind file & read first fields */
////   else {
////
////      /* constwind: false when wind is read from GRIB file */
////      constwind = 0;
////
////      sscanf(windfile,"%s",line);
////      if ((windin = fopen(line,"rb")) == NULL) {
////         fprintf(stderr, "Could not open file: %s\n", windfile);
////         exit(1);
////      }
////      printf(" Wind vector GRIB file: %-50s\n",windfile);
////
////     /* Read first two wind fields from file */
////      readgrib(uwold, windin, &wpos); /* u-component [m/s] */
////      readgrib(vwold, windin, &wpos); /* v-component */
          twold = t_wind[0];
////      readgrib(uwnew, windin, &wpos);
////      readgrib(vwnew, windin, &wpos);
          twnew = t_wind[1];

//      printf (" Wind grid: nx=%d, ny=%d\n", uwnew->nx,uwnew->ny);
//
////     /* Check that first wind field is prior to start of simulation */
          if (t0 < twold) {
             fprintf(stderr, "Error: No valid wind field found, start time too early\n");
             exit(1);
          }
          if (t0 > t_wind[DIMT_W-1]) {
             fprintf(stderr, "Error: Start time too late\n");
             exit(1);
          }
          if (t0 > t_curr[DIMT_C-1]) {
             fprintf(stderr, "Error: Start time too late\n");
             exit(1);
          }
//   } /* end if (constant wind) */

//
 /* Read initial particle distribution (lon,lat) from file seedin */

 /* Loop over all nmem particles in ensemble */
          int nstanded;
          for (k=0; k<nmem; k++)
          {
          fgets(line, MAXLEN, seedin); /* lines 46 and on ... */
          sscanf(line, "%d%g%g%d%g%g%6d", &idum, &lon[k], &lat[k], \
             &ort[k], &rdw[k], &rcw[k], &birth[k]);

/* Being honest: birth[k] rounded to nearest model timestep */
       // Check for particles already stranded when seeded
          stranded[k] = 0; // init
          nstanded=0;


     /* Negative downwind slope coefficients must be avoided as particles
      * should drift downwind. The problem arises because of high error
      * variances (see e.g. PIW-1).
      */
      eps = rdw[k]*lwsd[DW];
      while (lwa[DW]+eps/20.0<0.0) {
        rdw[k] = randn();      /* downwind */
        eps = rdw[k]*lwsd[DW];
      } /* end while */

   } /* end for: read particle distribution */
////
////  // Determine whether particles are stranded at the outset
////   vbilingrib(uc, v1, lon, lat, ucnew, vcnew, n);
////   vbilingrib(uw, v1, lon, lat, uwnew, vwnew, n);

     //  bilin(rec_curr,n,DIMX_C,DIMY_C,lon,lat,lon_curr, lat_curr, ucold, vcold, uc_d, vc_d);
     //  bilin(rec_wind,n,DIMX_W,DIMY_W,lon,lat,lon_wind, lat_wind, uwold, vwold, uw_d, vw_d);

       for (k=0; k<nmem; k++) {
           // Check initial location against coastline contour

         IsOnOffLand(k,&flag_i, DIMX_C, DIMY_C, onland,lon[k], lat[k], lonmap, latmap);

           if (flag_i==0) {
             stranded[k]=1;
            
        //      printf("%d\t%d\t%g\t%g\t%s\n",stranded[k],k,lon[k],lat[k],"nstranded");
             nstranded++;
           }
           state[k] = stranded[k] ? STRANDED : DRIFTING;
             ind[k]=k+1;
       } // endif nostrand

      printf("%d\t%s\n",nstranded,"nstranded");
//// /************************* MAIN LOOP STARTS ***********************************
////  *
////  * Starts at time t0 and advances until either the wind or the current file is
////  * exhausted or all particles have stranded or drifted out of the domain.
////  *
////  * If both winds and currents are constant (not read from file), the loop is
////  * stopped after MAXHOURS.
////  *
////  *****************************************************************************/

     double nl;
     t=t0;
    int rec_curr, rec_wind;
     rec_wind=0;
     rec_curr=0;


     while (!eot) {  /* eot is true if simulation is to continue */

    /* Count seeded particles, n, if still seeding */

           nold = n;
           if (t <= t1) {   /* still seeding? */

           n = 0;
         for (k=0; k<nmem; k++) { /* loop over all particles */
            if (birth[k] < t) n++;
         } /* end for k */
      } /* end if */

      for (k=0; k<nmem; k++) {

        /* Skip if particle is stranded */
         if (stranded[k]) {
            continue;
         }
           // Check initial location against coastline contour
         IsOnOffLand(k,&flag_i, DIMX_C, DIMY_C, onland,lon[k], lat[k], lonmap, latmap);

           if (flag_i==0) {
             stranded[k]=1;
             
             nstranded++;
           }
           state[k] = stranded[k] ? STRANDED : DRIFTING;
             ind[k]=k+1;
       } // endif nostrand

    /* Block: Interpolate current & wind fields in time & space ***************/
    float *uc1, *uc2, *vc1, *vc2, *uw1, *vw1, *uw2, *vw2;
    uc1 =    (float *)    malloc(nmem * sizeof(float));
    vc1 =    (float *)    malloc(nmem * sizeof(float));
    uw1 =    (float *)    malloc(nmem * sizeof(float));
    vw1 =    (float *)    malloc(nmem * sizeof(float));
    uc2 =    (float *)    malloc(nmem * sizeof(float));
    vc2 =    (float *)    malloc(nmem * sizeof(float));
    uw2 =    (float *)    malloc(nmem * sizeof(float));
    vw2 =    (float *)    malloc(nmem * sizeof(float));

    {

         float **uwind;
         int cond=0; 
         while (cond==0) 
         {
         twold = t_wind[rec_wind];
         twnew =t_wind[rec_wind+1];

         if ((twnew>t)&&(twold<=t)&&(twnew<t_wind[DIMT_W-1]))
         {
         /* End of wind file reached? */
      //   if (eot) break; /* then break from loop and finish */


          bilin(rec_wind,nmem,DIMX_W, DIMY_W,lon, lat,lon_wind, lat_wind, uwold, vwold, uw1, vw1);

          bilin(rec_wind+1, nmem,DIMX_W, DIMY_W,lon, lat,lon_wind, lat_wind, uwold, vwold, uw2, vw2);


         /* Linear time weight */
         float weight = ((float)(t-twold))/((float)(twnew-twold));
//        float *uc1, *uc2, *vc1, *vc2, *uw1, *vw1, *uw2, *vw2;
         inter_time(nmem, weight, uw1, vw1, uw2, vw2, uw, vw);
         cond=1;
         }
         else
         {
          rec_wind++;  
         }
         }
          cond=0;
         while (cond==0) 
         {
         tcold = t_curr[rec_curr];
         tcnew =t_curr[rec_curr+1];
         if ((tcnew>t)&&(t>=tcold)&&(tcnew<t_curr[DIMT_C-1]))
         {
     /* Interpolate current field in time and to particle positions */

         /* Linear time weight */
         float weight = ((float)(t-tcold))/((float)(tcnew-tcold));

         /* From grid to locations using vectorial bilinear interpolation */
         bilin(rec_curr,nmem,DIMX_C,DIMY_C,lon,lat,lon_curr, lat_curr, ucold, vcold, uc1, v1);
         bilin(rec_curr+1,nmem,DIMX_W,DIMY_W,lon,lat,lon_curr, lat_curr, ucold, vcold, uc2, v2);

         /* Interpolate current vectors in time */

         inter_time(nmem, weight, uc1, vc1, uc2, vc2, uc, vc);
         cond=1;
         } /* end if (!constcurr) */
         else 
         {
          rec_curr++;
         }
     } 

    } /* end block: interpolate current and wind ******************************/

  /* Output to file at user-specified intervals */
//printf("%d\t%d\t%s\n",t, outputinterval,"outputin");
// if (t % outputinterval == 0) {
 //      meanposition(&meanlon,&meanlat,lon,lat,n);
 //      printout(fout, t0+t, istepout, outputinterval, n, nold, nmem, meanlon, meanlat, \
                lon, lat, state, stranded, birth, ort);
 //      printout_traj(fout_traj,n,istepout,ind,lon,lat,state,stranded,birth,ort);
 //      printout_mean(fout_mean, istepout, outputinterval, n, nold,meanlon,meanlat);
 //      istepout++;
 //      printf("%d\t%d\t%s\n",t, outputinterval,"outputout");
 //   }

//  /* Block: Advect particles *************************************************
//   *
//   * Compute leeway drift (windage) and advect particles accordingly.
//   * The total drift is the sum of surface current (no slippage) and the leeway.
//   *
//   * 2nd order Runge-Kutta is used to advect particles.
//   *
//   * References:
//   *
//   * Press, W H,  S A Teukolsky, W T Vetterling and B P Flannery, 1992:
//   * "Numerical Recipes in FORTRAN, 2nd edition", Cambridge University Press
//   *
//   */
    {
    /* Block variables (only visible within this block) */
      float urel, vrel,ucp,vcp,uwp,vwp;
      float dist, dir, dx, dy, newlon, newlat;
  //    float *uc1, *uc2, *vc1, *vc2, *uw1, *vw1, *uw2, *vw2;


    /* Advect: Euler first order trial step AND jibing.
     *
     * Used to estimate current and wind at midpoint for Runge-Kutta 2nd order
     * advection scheme.
     */

      for (k=0; k<nmem; k++) {

         /* Skip if particle is stranded */
         if (stranded[k]) {
            continue;
         }

         /* Jibe? compute hourly probability of jibing */
         rnd = ((float) rand()) / ((float) RAND_MAX);
         if ( rnd < (((float)dt)/3600.0)*pjibe ) {
            ort[k]=1-ort[k]; /* Change orientation of ensemble member */
         }

         /* Set undef current or wind to zero if coastline database is used
            or if stranding is not wanted */
//         if ( nostrand || hascoastline ) {
//            if ( isnan(fabsf(uc[k])) || isnan(fabsf(vc[k])) ) {
//               uc[k] = 0.0;
//               vc[k] = 0.0;
//            }
//            if ( isnan(fabsf(uw[k])) || isnan(fabsf(vw[k])) ) {
//               uw[k] = 0.0;
//               vw[k] = 0.0;
//            }
//         } // endif nostrand || hascoastline
//
         /* Generate Gaussian current perturbations - only done for Euler step */
         ucpert[k] = randn()*ucsd;
         vcpert[k] = randn()*vcsd;

         /* Add Gaussian perturbations to current vector */
         ucp = uc[k] + ucpert[k];
         vcp = vc[k] + vcpert[k];

         /* Generate Gaussian wind perturbations - only done for Euler step */
         uwpert[k] = randn()*uwsd;
         vwpert[k] = randn()*vwsd;

         /* Add Gaussian perturbations to wind vector */
         uwp = uw[k] + uwpert[k];
         vwp = vw[k] + vwpert[k];
      //   printf("%g\t%g\t%g\t%g\n",uw[k],vw[k],uc[k],vc[k]);

         /* Compute leeway */
         leeway(&urel, &vrel, uwp, vwp, lwa, lwb, lwsd, rdw[k], rcw[k], ort[k]);

         /* Compute displacement to Euler midpoint */
        
         dx = ((float) dt)*(ucp+urel); /* east displ [m] = [s]*[m/s] */
         dy = ((float) dt)*(vcp+vrel); /* north displacement */
         dist = 0.5*sqrt(dx*dx+dy*dy); /* displacement to midpoint [m] */
         dir = DEG*atan2(dx, dy);  /* bearing [deg clockwise from north] */
         spherepos(&newlon, &newlat, lon[k], lat[k], -dist, dir);

         // Save old lon & lat for coastline intersect
         oldlon[k]=lon[k];
         oldlat[k]=lat[k];

         lon1[k] = dang180(newlon); /* Intermediate position [deg] */
         lat1[k] = newlat;

         IsOnOffLand(k,&flag_i, DIMX_C, DIMY_C, onland,lon1[k], lat1[k], lonmap, latmap);

           if (flag_i==0) {
             stranded[k]=1;
            
             nstranded++;
           }
           state[k] = stranded[k] ? STRANDED : DRIFTING;
             ind[k]=k+1;


      } /* end for: Euler 1st order trial step */

      /* Bilinear interpolation of current and wind at Euler midpoint */
         if ((tcnew>t)&&(t>=tcold)&&(tcnew<t_curr[DIMT_C-1]))
         {    

         float weight = ((float)(t-dt/2-tcold))/((float)(tcnew-tcold));
         bilin(rec_curr,nmem,DIMX_C, DIMY_C,lon1, lat1, lon_curr, lat_curr, ucold, vcold, uc1, vc1);
         bilin(rec_curr+1,nmem,DIMX_C, DIMY_C,lon1, lat1,lon_curr, lat_curr, ucold, vcold, uc2, vc2);

         /* Interpolate wind vectors in time */
         inter_time(nmem, weight, uc1, vc1, uc2, vc2, uc, vc);
       }

         
         if ((twnew>t)&&(twold<=t)&&(twnew<t_wind[DIMT_W-1]))
         {
         float weight = ((float)(t-dt/2-twold))/((float)(twnew-twold));
         bilin(rec_wind,nmem,DIMX_W, DIMY_W, lon1, lat1,lon_wind, lat_wind, uwold, vwold, uw1, vw1);
         bilin(rec_wind+1, nmem,DIMX_W, DIMY_W,lon1, lat1,lon_wind, lat_wind, uwold, vwold, uw2, vw2);

      //   vbilingrib(u1, v1, lon1, lat1, uwold, vwold, n);
      //   vbilingrib(u2, v2, lon1, lat1, uwnew, vwnew, n);

        /* Interpolate wind vectors in time */
         inter_time(nmem, weight, uw1, vw1, uw2, vw2, uw, vw);
          }
         

     // Update stranded and lost particles after Euler step

//     for (k=0; k<nmem; k++) {
//           // Check initial location against coastline contour
//
//         IsOnOffLand(&flag_i, DIMX_C, DIMY_C, onland,lon1[k], lat1[k], lonmap, latmap);
//            stranded[k]=flag_i;
//
//       } // endif nostrand

////      if (!nostrand) {
////        // GSHHS intersection
////         if (hascoastline) {
////            intersect_coastline(stranded, &nstranded, &inter, oldlon, oldlat, lon1, lat1, n);
////            // Flag offgrid particles
////            offgrid_particles(stranded, offgrid, &nstranded, &noffgrid, uc, uw, n);
////         }
////        // Else if GSHHS contour is missing
////         else {
////            stranded_particles(stranded, offgrid, &nstranded, &noffgrid, uc, uw, n);
////         }
////      } // endif nostrand
//
//     Advect: Runge-Kutta 2nd order step (RK2)

      for (k=0; k<nmem; k++) { /* loop over active particles */

         /* Skip if particle is stranded */
         if (stranded[k]) {
            continue;
         }

         /* Set undef current or wind to zero if coastline database is used
            or if stranding is not wanted */
//         if ( nostrand || hascoastline ) {
//            if ( isnan(fabsf(uc[k])) || isnan(fabsf(vc[k])) ) {
//               uc[k] = 0.0;
//               vc[k] = 0.0;
//            }
//            if ( isnan(fabsf(uw[k])) || isnan(fabsf(vw[k])) ) {
//               uw[k] = 0.0;
//               vw[k] = 0.0;
////            }
////         } // endif nostrand || hascoastline
//
         /* Add Gaussian perturbations to current vector */
         ucp = uc[k] + ucpert[k];
         vcp = vc[k] + vcpert[k];

         /* Add Gaussian perturbations to wind vector */
         uwp = uw[k] + uwpert[k];
         vwp = vw[k] + vwpert[k];
       //  printf("%g\t%g\n",uw[k],vw[k]);

         /* Compute leeway */
         leeway(&urel, &vrel, uwp, vwp, lwa, lwb, lwsd, rdw[k], rcw[k], ort[k]);

         uvdrift[k]=ucp+urel;
         vvdrift[k]=vcp+vrel;

         /* Advect particle (leeway + current) */
        //  printf("%g\t%g\t%g\t%g\n",uc[k], uw[k],vc[k],vw[k]);
         dx = ((float) dt)*(ucp+urel); /* east displ, [m] = [s]*[m/s] */
         dy = ((float) dt)*(vcp+vrel); /* north displacement */
         dist = sqrt(dx*dx+dy*dy); /* displacement [m] */
        // printf("%g\t%g\t%g\t%d\n",dist, dx,dy,dt);
         dir = DEG*atan2(dx, dy);  /* bearing [deg clockwise from north] */
    //      printf("%g\t%g\t%d\t%d\n",ucp,vcp,nstranded,istep);

         /* New particle position */
         spherepos(&newlon, &newlat, lon[k], lat[k], -dist, dir);
      //   printf("%g\t%g\t%d\t%d\n",newlon,newlat,nstranded,istep);

         lon[k] = dang180(newlon); /* [deg] */
         lat[k] = newlat;
         IsOnOffLand(k,&flag_i, DIMX_C, DIMY_C, onland,lon[k], lat[k], lonmap, latmap);

           if (flag_i==0) {
             stranded[k]=1;
          
             nstranded++;
           }
           state[k] = stranded[k] ? STRANDED : DRIFTING;
             ind[k]=k+1;
       //    printf("%g\t%g\t%d\t%d\n",lon[k],lat[k],nstranded,istep);
          //printf("%g\t%g\t%d\t%d\n",newlon,newlat,nstranded,istep);
      
      } /* end for RK2 */
          if ((t-t0) % outputinterval == 0) {  
       for (k=0; k<nmem; k++) { /* loop over active particles */
        
        fprintf(fout_traj, "%4d\t%9.4f\t%8.4f\t%3d\t%d\t%2d\t%d\n", ind[k], lon[k],lat[k],state[k],birth[k],ort[k],istepout);
     //   printf("%4d\t%9.4f\t%8.4f\t%3d\t%d\t%2d\t%d\n", ind[k], lon[k],lat[k],state[k],birth[k],ort[k],istepout);
      } 
      }  

     //  printout_vel(fout_vel,n,istepout,ind,uvdrift,vvdrift,state,stranded,birth,ort);
     //  printout_mean(fout_mean, istepout, outputinterval, n, nold,meanlon,meanlat);
        printf("%d\t%d\t%s\n",t, outputinterval,"outputout");
       istepout++;
   //}

    } /* end block: advect particles ******************************************/

//        for (j=0; j<nmem; j++) {
//           // Check initial location against coastline contour
//         IsOnOffLand(&flag_i, DIMX_C, DIMY_C, onland,lon[j], lat[j], lonmap, latmap);
//            stranded[j]=flag_i;
//            nstanded++;
//
//       } // endif nostrand
  // Update stranded and lost particles after RK2 step

//    if (!nostrand) {
//       if (hascoastline) {
//          offgrid_particles(stranded, offgrid, &nstranded, &noffgrid, uc, uw, n);
//          intersect_coastline(stranded, &nstranded, &inter, oldlon, oldlat, lon, lat, n);
//       }
//      // Only if GSHHS contour is missing
//       else {
//          stranded_particles(stranded, offgrid, &nstranded, &noffgrid, uc, uw, n);
//       }
//    } /* endif nostrand*/
//   if ((t-t0) % outputinterval == 0) {
//       meanposition(&meanlon,&meanlat,lon,lat,n);
//       printout(fout, t, istepout, outputinterval, n, nold, nmem, meanlon, meanlat, \
//                lon, lat, state, stranded, birth, ort);
//       printout_traj(fout_traj,n,istepout,ind,lon,lat,state,stranded,birth,ort);
//       printout_vel(fout_vel,n,istepout,ind,uvdrift,vvdrift,state,stranded,birth,ort);
//       printout_mean(fout_mean, istepout, outputinterval, n, nold,meanlon,meanlat);
//       istepout++;
//    }


  /* Update time */

    t += dt;

    istep++; /* time step counter */


  /* Stop sim after MAXHOURS if both winds AND currents are constant */

    if (t > tend) {

        for (k=0;k<nmem;k++){
          
        fprintf(fout_final_traj,"%d\t%9.4f\t%9.4f\t%d\n", ind[k],lon[k],lat[k],state[k]);
        }
            printf("%d\t%s\n",t,"ydes");
            eot=1;}


  /* Stop sim if all particles are stranded */

    if (nstranded >= nmem)  eot=1;
  //  if (noffgrid >= nmem) eot=1;
// for (k=0;k<n;k++)
//              {
/*      *ttstep=1; */
//      fscanf(fout_traj,"%4d\t%g\t%g\t%d\t%ld\t%d\n", &ind[k], &lon[k], &lat[k], &state[k], &birth[k],&ort[k]);
/*      fprintf(fout_final, "%d\t%9.4f\t%9.4f\t%ld\n", ind[k],lon[k], lat[k],(long)((float)birth[k]));*/
/*     printf("%4d\t%9.4f\t%9.4f\t%2d\t%4d\n", ind[k], lon[k], lat[k],cl[k],i); */
/*  if (state[k]==41) {
//          cl[ind[k]]=-2;} */
//   if ((state[k]==42)||(state[k]==44)) {
//          cl[ind[k]]=-3;}
//}
//
   } /* end main loop */


  fclose(fout_traj);

//   FILE *f_traj;
//
//   char name_f_traj[] = "leeway_traj_";
//    sprintf(c_num, "%s", argv[3]);
//     strcat(name_f_traj, c_num);
//     strcat(name_f_traj, ".dat");
//
//
//   f_traj = fopen(name_f_traj,"r");
//   printf("%s\n",name_f_traj);
//   float lon_dr, lat_dr;
//   float *lon_drifter,*lat_drifter;
//   lon_drifter =   (float *)    malloc(nmem * sizeof(float));
//   lat_drifter =   (float *)    malloc(nmem * sizeof(float));
//   int state_dr,ort_dr,cl_dr;
//   int birth_dr;
//   int ind_dr,inew;
////   i=0;
////   n=0;
//      *ttstep=1;
//   //   fscanf(fout_final,"%4d\t%g\t%g\t%d\t%d\n", &ind[k], &lon[k], &lat[k], &state[k], &birth[k])!=EOF;
//     //   while (feof(f_traj)!=1){
////      inew=i;
//      fscanf(f_traj, "%d\t%g\t%g\t%d\t%d\t%d\t%d\n", &ind_dr, &lon_dr, &lat_dr, &state_dr, &birth_dr,&ort_dr,&i);
//
////      if (i==istep-1){
////            IsOnOffLand(ind_dr,&flag_i, DIMX_C, DIMY_C, onland,lon_dr, lat_dr, lonmap, latmap);
////
////           if (flag_i==0) {
////             state_dr=41;
////           }
////      fprintf(fout_final_traj,"%d\t%9.4f\t%9.4f\t%d\n", ind_dr,lon_dr,lat_dr,state_dr);
////      printf("%d\t%9.4f\t%9.4f\t%d\n", ind_dr,lon_dr,lat_dr,istep);
////      }
//   //   fprintf(fout_final, "%d\t%9.4f\t%9.4f\t%2d\n", ind_dr,lon_dr,lat_dr,state_dr);
////      }
////    printf("%d\t%s\n",istep-1, "step");
 // Close files

   fclose(seedin);
  // fclose(fout);
  // fclose(f_traj);
  // fclose(fout_vel);
  // fclose(fout_final);
   fclose(fout_final_traj);
   fclose(fout_distr);
   fclose(mapin);
   fclose(mapin1);
//   if (!constcurr) fclose(currin);
//   if (!constwind) fclose(windin);


 /* All is well */

   return 0;

} /* end main() */

/**************************** END MAIN ****************************************/

/* Compute leeway motion */
void leeway(float *urel, float *vrel, float uw, float vw, float *lwa, float *lwb, float *lwsd, float rdw, float rcw, int ort)
{
   /* Interface
   out *urel // pointer to leeway east component [m/s]
   out *vrel // pointer to leeway north component [m/s]
   in  uw    // east component of wind [m/s]
   in  vw    // north component of wind [m/s]
   in  lwa   // array[3] of leeway slope coefficients [%]
   in  lwb   // array[3] of leeway offset coefficients [m/s]
   in  lwsd  // array[3] of standard deviation of leeway coefficients [m/s]
   in  rdw   // random number N(0,1) for downwind leeway coeff pert
   in  rcw   // random number N(0,1) for crosswind leeway coeff pert
   in  ort   // orientation of object [0 right | 1 left of downwind]
   */

   /* Vars */
   float wsp;   /* wind speed [m/s] */
   float theta; /* wind dir GOING TO [rad clockw from north] */
   float eps[3], dwl, cwl;
   float lee, alpha, chi;
   int cw;

   /* Convert wind vector to speed and direction rel to north */
   wsp = sqrt(uw*uw+vw*vw); /* [m/s] */
   theta = atan2(uw,vw); /* wind dir GOING TO [rad clockw from north] */

   /* Add time-invariant Gaussian perturbations to leeway coeffs */
   eps[DW] = rdw*lwsd[DW]; /* downwind */
   cw = ort; /* 0 is right of downwind, 1 is left of downwind */
   eps[cw] = rcw*lwsd[cw]; /* crosswind */

   /* Compute leeway vector [cm/s] from linear regression formula */
   /* [Allen & Plourde, 1999] */

   dwl = (lwa[DW]+eps[DW]/20.0)*wsp + lwb[DW]+eps[DW]*0.5; /* downwind */
   cwl = (lwa[cw]+eps[cw]/20.0)*wsp + lwb[cw]+eps[cw]*0.5; /* crosswind */

   /* Leeway speed and drift direction relative to downwind */
   lee = sqrt(dwl*dwl+cwl*cwl); /* leeway magnitude [cm/s] */
   alpha = atan2(cwl,dwl);      /* [rad clockw from downwind dir] */

   /* Leeway drift direction relative to north */
   chi = theta + alpha; /* leeway dir clockw rel to north [rad] */

   /* Leeway east and north components (relative to surface current),
    * convert [cm/s] to [m/s] */
   *urel = lee*sin(chi)*0.01; /* east  component of leeway [m/s] */
   *vrel = lee*cos(chi)*0.01; /* north component of leeway [m/s] */

} /* end leeway() */


void stranded_particles(int *stranded, int *offgrid, int *nstranded, int *noffgrid, float *uc, float *uw, int n)
/* Stranded and lost particles.
 *
 * The current implementation considers a particle "stranded" if either the
 * current or wind grid returns "undef" in that particular position.
 * The boundaries of the current and wind grids are thus interpreted as land.
 * However, the logical array offgrid reveals whether the particle really
 * stranded or drifted off the model domain. */
{
   /* Interface
   out *stranded  // pointer to logical array identifying stranded AND
                  // off grid particles
   out *offgrid   // pointer to logical array identifying particles off grid
   out *nstranded // pointer to number of stranded particles
   out *noffgrid  // pointer to number of off grid particles
   in  *uc        // pointer to east component current
   in  *uw        // pointer to east component wind
   in  n          // length of arrays
   */

   /* Local vars */
   int k;

   /* Loop over active particles */
   for (k=0; k<n; k++) {
      if (!stranded[k]) {
         stranded[k] = ( isnan(fabsf(uc[k])) || isnan(fabsf(uw[k])) );
         *nstranded+=stranded[k];

         offgrid[k] = ( isnan(-uc[k]) ||  isnan(-uw[k]) );
         *noffgrid+=offgrid[k];
      }
   } /* end for k */
} /* end stranded_particles() */


void offgrid_particles(int *stranded, int *offgrid, int *nstranded, int *noffgrid, float *uc, float *uw, int n)
/* Particles over the edge of the grid.
 *
 * A particle is offgrid if the current or wind grid returns undef in that particular position.
 */
{
   /* Interface
   in  *stranded  // pointer to logical array identifying stranded particles
   out *offgrid   // pointer to logical array identifying particles off grid
   out *nstranded // pointer to number of stranded particles
   out *noffgrid  // pointer to number of off grid particles
   in  *uc        // pointer to east component current
   in  *uw        // pointer to east component wind
   in  n          // length of arrays
   */

   /* Local vars */
   int k;

  /* Loop over active particles */
   for (k=0; k<n; k++) {
      if (!stranded[k]) {
         offgrid[k] = ( isnan(-uc[k]) ||  isnan(-uw[k]) );
         //stranded[k] = offgrid[k];
         *noffgrid+=offgrid[k];
         *nstranded+=offgrid[k];
      }
   } /* end for k */
} /* end offgrid_particles() */
void IsOnOffLand(int k, int *flag_i, int DIMX_C, int DIMY_C,int onland[DIMY_C][DIMX_C],float ln,float lt, float maplon[DIMX_C], float maplat[DIMY_C])
{
  int i,j;
  float maxlon=maplon[0], minlon=maplon[0], maxlat=maplat[0], minlat=maplat[0];
  for (i=0; i<DIMX_C; i++) {
   for (j=0; j<DIMY_C; j++){
       if (maxlon<=maplon[i]){
            maxlon=maplon[i];
       }
       if (minlon>=maplon[i]){
            minlon=maplon[i];
       }
       if (maxlat<=maplat[j]){
            maxlat=maplat[j];
       }
       if (minlat>=maplat[j]){
            minlat=maplat[j];
       }
   }
  }
  *flag_i=1;
  if ((ln>maxlon)||(ln<minlon)||(lt>maxlat)||(lt<minlat)){
         *flag_i=0;
      //   printf("%g\t%g\t%g\t%g\t%g\t%g\n",ln,lt,minlon,maxlon,minlat,maxlat);
  }
  else
  {
  for (i=0; i<DIMX_C-1; i++) {
   for (j=0; j<DIMY_C-1; j++){
    if ((ln>=maplon[i])&&(ln<maplon[i+1])){
        if ((lt>=maplat[j])&&(lt<maplat[j+1])){
           if ((onland[j][i]==0)||(onland[j+1][i]==0)||(onland[j][i+1]==0)||(onland[j+1][i+1]==0)){
            *flag_i=0;
        //    printf("%d\n",j+i*DIMY_C);
         //   printf("%g\t%g\t%g\t%g\t%d\t%d\n",maplat[j],maplat[j-1],maplon[i],maplon[i-1],i,j);
           }
           else{
            *flag_i=1;
           //   printf("%d\t%g\t%g\t%g\t%g\t%g\t%g\n",k, ln,lt,maplat[j],maplat[j+1],maplon[i],maplon[i+1]);
           }
        }
     }
    }
   }
 }
}
void intersect_coastline(int *stranded, int *nstranded, GSHHSIntersect *inter, float *oldlon, float *oldlat, float *newlon, float *newlat, int n)
// Returns *stranded logical vector.
// Double-checks by also testing the new position against IsOnLandSimple
{
  double lon0, lat0, lon1, lat1, coords[3];
  int k;

  /* Loop over active particles */
   for (k=0; k<n; k++) {
      if (!stranded[k]) {
         lon0=(double) oldlon[k];
         lat0=(double) oldlat[k];
         lon1=(double) newlon[k];
         lat1=(double) newlat[k];
         calcIntersection(*inter,lon0,lat0,lon1,lat1,coords);
         if ( !gshhsundef(coords[0]) ) {
            stranded[k]=1;
            (*nstranded)++;
            newlon[k] = (float) coords[0];
            newlat[k] = (float) coords[1];
         } // end if
      } // end if
   } /* end for k */
} /* end intersect_coastline() */

void printout_traj(FILE *fout_traj,int n,int istepout, int *ind,float *lon, float *lat, int *state,int *stranded, int *birth, int *ort)
{
/* ASCII output of ensemble information at user-specified intervals. */

  /* Local vars */
   int k;
   int ind_r, birth_r,ort_r, istepout_r, state_r;
   float lon_r, lat_r;

  /* Write particle data (ort=0 is right of downwind). */
   for (k = 0; k<n; k++) { /* loop over active particles */
  // if (state[k]!=44) {
      state[k] = stranded[k] ? STRANDED : DRIFTING;
      ind[k]=k+1;
      fprintf(fout_traj, "%4d\t%9.4f\t%8.4f\t%3d\t%d\t%2d\t%d\n", ind[k], lon[k],lat[k],state[k],birth[k],ort[k],istepout);
    //  fscanf(fout_traj, "%4d\t%9.4f\t%8.4f\t%3d\t%d\t%2d\t%d\n", &ind_r, &lon_r,&lat_r, &state_r,&birth_r,&ort_r,&istepout_r);
   } /* end for k */
   }
/* end printout() */
/*void printout_traj_final(FILE *fout_final,FILE *fout_traj,int *cl, int n)
{
int k,ind_d,state_d,ort_d;
float lon_d,lat_d,birth_d;

     while (!eof(fout_traj))
    {  for (k=1;k<n;k++)
              {
      fscanf(fout_traj,"%4d\t%9.4f\t%8.4f\t%3d\t%6ld\t%2d\n", &ind_d, &lon_d, &lat_d, &state_d, &birth_d, &ort_d);
      fprintf(fout_final, "%4d\t%9.4f\t%8.4f\t%2d\n", ind_d, lon_d, lat_d,cl[k]);
   } * end for k */
 /* end printout() */
void printout_vel(FILE *fout_vel,int n,int istepout, int *ind,float *uvdrift, float *vvdrift, int *state,int *stranded, int *birth, int *ort)
{
/* ASCII output of ensemble information at user-specified intervals. */

  /* Local vars */
   int k;

  /* Write particle data (ort=0 is right of downwind). */
   for (k = 0; k<n; k++) { /* loop over active particles */
      state[k] = stranded[k] ? STRANDED : DRIFTING;
      ind[k]=k+1;
      fprintf(fout_vel, "%4d\t%9.4f\t%8.4f\t%3d\t%6ld\t%2d\t%d\n", ind[k],uvdrift[k],vvdrift[k],state[k],(long)((float)birth[k]/60.0),ort[k],istepout);
   } /* end for k */
} /* end printout() */
/*void printout_traj_final(FILE *fout_final,FILE *fout_traj,int *cl, int n)
 * {
 * int k,ind_d,state_d,ort_d;
 * float lon_d,lat_d,birth_d;
 *
 *      while (!eof(fout_traj))
 *          {  for (k=1;k<n;k++)
 *                        {
 *                              fscanf(fout_traj,"%4d\t%9.4f\t%8.4f\t%3d\t%6ld\t%2d\n", &ind_d, &lon_d, &lat_d, &state_d, &birth_d, &ort_d);
 *                                    fprintf(fout_final, "%4d\t%9.4f\t%8.4f\t%2d\n", ind_d, lon_d, lat_d,cl[k]);
 *                                       } * end for k */
 /* end printout() */
void printout_traj_cluster(FILE *fout_cluster_mean,int n,int num_clusters,int *num_points_Cl,float *lon,\
 float *lat, int *cl,int st)
{
int k,j;
float sum_lon[n],sum_lat[n],mean_traj_lat[n],mean_traj_lon[n];
/*printf("%d\t%d\n",num_clusters,*step); */
for (k=1;k<num_clusters+1;k++){
sum_lat[k-1]=0;
sum_lon[k-1]=0;
for (j=0;j<n;j++){
if (cl[j]==k){
sum_lat[k-1]+=lat[j];
sum_lon[k-1]+=lon[j];}
/*printf("%6d\t%8.4f\t%8.4f\t%4d\n",k,sum_lon[k-1],sum_lat[k-1],st);*/
}
/*printf("%6d\t%8.4f\t%8.4f\n",st,lon[1],lat[1]);*/
if (num_points_Cl[k-1] >0){
mean_traj_lat[k-1]=sum_lat[k-1]/num_points_Cl[k-1];
mean_traj_lon[k-1]=sum_lon[k-1]/num_points_Cl[k-1];
}
fprintf(fout_cluster_mean,"%6d\t%8.4f\t%8.4f\t%4d\n",k,mean_traj_lon[k-1],mean_traj_lat[k-1],st);
/*printf("%6d\t%8.4f\t%8.4f\t%4d\n",k,mean_traj_lon[k-1],mean_traj_lat[k-1],st);*/
}}
void printout_mean(FILE *fout_mean,int istepout, int outputinterval, int n, int nold,float meanlon, float meanlat)
{
  /* Local vars */

   fprintf(fout_mean, "%9.4f\t%8.4f\t%6d\t%5d\t%4d\t%4d\n", meanlon, meanlat,(int) (istepout*outputinterval/60),\
    istepout+1, n-nold, n);

} /* end printout() */

void printout(FILE *fout, time_t now, int istepout, int outputinterval, int n, int nold,\
 int nmem, float meanlon, float meanlat, float *lon, float *lat, int *state, \
 int *stranded, int *birth, int *ort)
{
/* ASCII output of ensemble information at user-specified intervals. */

  /* Local vars */
   struct tm *ptm;    /* pointer to time-struct */
   int yyyy, mm, dd, hh, mi, ss;
   int k;

   fprintf(fout, "\n"); /* line feed separates output times */

   ptm = gmtime(&now);
   yyyy = ptm->tm_year+1900;
   mm = ptm->tm_mon+1;
   dd = ptm->tm_mday;
   hh = ptm->tm_hour;
   mi = ptm->tm_min;
   ss = ptm->tm_sec;

   fprintf(fout, "# Date [UTC]:\n");
   fprintf(fout, "nowDate\tnowTime\n");
   fprintf(fout, "%4d-%02d-%02d\t%02d:%02d:%02d\n", yyyy, mm, dd, hh, mi, ss);

   fprintf(fout, "# Time passed [min] & [timesteps], now seeded, seeded so far:\n");
   fprintf(fout, "timePassed\tnStep\tnowSeeded\tnSeeded\n");
   fprintf(fout, "%6d\t%5d\t%4d\t%4d\n", (int) (istepout*outputinterval/60),\
    istepout+1, n-nold, n);

   fprintf(fout, "# Mean position:\n");
   fprintf(fout, "meanLon\tmeanLat\n");
   fprintf(fout, "%9.4f\t%8.4f\n", meanlon, meanlat);

   fprintf(fout, "# Particle data:\n");
   fprintf(fout, "id\tlon\tlat\tstate\tage\torientation\n");

  /* Write particle data (ort=0 is right of downwind). */
   for (k = 0; k<n; k++) { /* loop over active particles */
  // if (state[k]!=44) {
//   printf("%d\t%d\t%d\n",k,stranded[k],istepout);
      state[k] = stranded[k] ? STRANDED : DRIFTING;
      fprintf(fout, "%4d\t%9.4f\t%8.4f\t%3d\t%6d\t%2d\n", k+1, lon[k], \
       lat[k], state[k],birth[k], ort[k]);
   } /* end for k */
} /* end printout() */

void meanposition(float *meanlon, float *meanlat, float *lon, float *lat, int n)
{
/* Compute center of mass (meanlon, meanlat).
 *
 * Note that stranded particles contribute to the center of mass. Thus,
 * when a sizeable number of particles have stranded, the mean position may
 * seem off compared to the centre of gravity of the particles still drifting.
 */

 /* Local vars */
   double x1 = 0.0, x2 = 0.0, x3 = 0.0, a, r, lambda, rn = (double) n;
   int k;
   double an;

 /* Loop over active particles */
   for (k=0; k<n; k++) {
      a = PI/2.0 - ((double) lat[k])*RAD;    /* [rad] */

      lambda = dang180((double) lon[k]);
    /* Compute Cartesian coordinates from lat/lon */
      x1 += sin(a)*cos(lambda);
      x2 += sin(a)*sin(lambda);
      x3 += cos(a);
   } /* end for k */

   x1 /= rn;
   x2 /= rn;
   x3 /= rn;
   r = sqrt(x1*x1+x2*x2+x3*x3);
   a = acos(x3/r);                     /* [rad] */
   lambda = asin(x2/(r*sin(a)));       /* [rad] */

   *meanlon = dang180(lambda*DEG); /* [deg] */
   *meanlat = (float) ((PI/2.0-a)*DEG);    /* [deg] */
}/*end meanposition*/

void inter_distr(FILE *fout_interdist,int n,float *lon,float *lat,float *uvdrift, float *vvdrift, float *mean_dist,float *mean_dist_vel)
{
/* this subroutine calculates distribution of distance between neighbours and distribution of velocity difference beetwen neighbours */
int k,i,ii=0;
int maxn=(int)((n-1)*n/2);
float step_dist,step_vel,min_dist,max_dist,max_vel,min_vel,maxnumber1,minnumber1,maxnumber2;
float *distr_distance,*distr,*distr_dist,*distr_vel,*distr_v,*distr_velocity;
distr_distance= (float *) malloc(maxn * sizeof(float));
distr_dist= (float *) malloc(150 * sizeof(float));
distr= (float *) malloc(150 * sizeof(float));
distr_vel= (float *) malloc(maxn * sizeof(float));
distr_velocity= (float *) malloc(150 * sizeof(float));
distr_v= (float *) malloc(150 * sizeof(float));
for (i=0;i<n-1;i++){
for (k=i+1;k<n;k++){
distr_distance[ii]=2*EARTH_R*asin(sqrt(pow(sin(PI/180*((float)lat[i]-(float)lat[k])/2),2)+cos(PI/180*(float)lat[i])*\
cos(PI/180*(float)lat[k])*pow(sin(PI/180*((float)lon[i]-(float)lon[k])/2),2)));
distr_vel[ii]=sqrt(pow(uvdrift[i]-uvdrift[k],2)+pow(vvdrift[k]-vvdrift[i],2));
ii+=1;}
}
for (i=0;i<n;i++){

maxmin_array(maxn,distr_distance,&max_dist,&min_dist);
maxmin_array(maxn,distr_vel,&max_vel,&min_vel);
step_dist=(max_dist-min_dist)/150;
step_vel=(max_vel-min_vel)/150;
for (k=0;k<150;k++) {
distr[k]=min_dist+step_dist*k;
distr_v[k]=min_vel+step_vel*k;
}
for (k=0; k<149;k++){
distr_dist[k]=0;
distr_velocity[k]=0;
}
maxnumber1=0;
maxnumber2=0;
for( k=0; k<149;k++){
for (i=0;i<maxn;i++) {
if ((distr_distance[i]>distr[k])&&(distr_distance[i]<=distr[k+1])) {
distr_dist[k]+=1;}
if ((distr_vel[i]>distr_v[k])&&(distr_vel[i]<=distr_v[k+1])) {
distr_velocity[k]+=1;}
}
distr_dist[k]=distr_dist[k]/maxn*100;
distr_velocity[k]=distr_velocity[k]/maxn*100;
fprintf(fout_interdist,"%d\t%7.2f\t%7.2f\t%7.2f\t%7.2f\n",k,distr[k],distr_dist[k],distr_v[k],distr_velocity[k]);
if (distr_dist[k]>maxnumber1) {
maxnumber1=distr_dist[k];
*mean_dist=(distr[k]+distr[k+1])/2;
}
}
if (distr_velocity[k]>maxnumber2) {
maxnumber2=distr_velocity[k];
*mean_dist_vel=(distr_v[k]+distr_v[k+1])/2;
}
}
}
void compute_distr(FILE *fout_distr,int n,float *lon,float *lat,float *distrln,float *distrlt,float *distr_lon,float *distr_lat)
{
int i,k;
float step_lat,step_lon,max_lon,min_lon,max_lat,min_lat;
maxmin_array(n,lat,&max_lat,&min_lat);
maxmin_array(n,lon,&max_lon,&min_lon);
step_lat=(max_lat-min_lat)/150;
step_lon=(max_lon-min_lon)/150;
for (k=0;k<150;k++) {
distr_lat[k]=min_lat+step_lat*k;
distr_lon[k]=min_lon+step_lon*k;
}
for(k=0; k<149;k++){
distrln[k]=0;
distrlt[k]=0;
}
for(k=0; k<149;k++){
for (i=0;i<n;i++) {
if ((lon[i]>distr_lon[k])&&(lon[i]<=distr_lon[k+1])) {
distrln[k]+=1;
}
if ((lat[i]>distr_lat[k]) && (lat[i]<=distr_lat[k+1])) {
distrlt[k]+=1;
}
}
distrln[k]=distrln[k]/n*100;
distrlt[k]=distrlt[k]/n*100;
fprintf(fout_distr,"%d\t%4.3f\t%4.3f\t%4.3f\t%4.3f\n",k,distrln[k],distrlt[k],distr_lon[k],distr_lat[k]);
}
}
void maxmin_array(int nin, float *array, float *max_array,float *min_array)
{
int i;
*max_array=array[0];
*min_array=array[0];
for (i=0; i<nin; i++) {
if (array[i]>*max_array) {
*max_array=array[i];
}
if (array[i]<*min_array) {
*min_array=array[i];
}
}
}
void regionQuery(float EPS_CLUSTER1,int n,float *p_s,float *v_s,float *traj_lon,float *traj_lat,float * velu,float *velv,int *num_Pts_s,int *ind_neighbors)
/* subroutine calculates number of neighbors for a given drifter point p_s based on Haversine formula*/
{
int k;
double dist1;
/*printf("%2d\n",num_Pts_s);*/
for (k=0; k<n; k++) {
/* initialize index of neighbors to zero */
dist1=2*EARTH_R*asin(sqrt(pow(sin(PI/180*((double)p_s[2]-(double)traj_lat[k])/2),2)+cos(PI/180*(double)p_s[2])*\
cos(PI/180*(double)traj_lat[k])*pow(sin(PI/180*((double)p_s[1]-(double)traj_lon[k])/2),2)));
if (dist1<=EPS_CLUSTER1) {
ind_neighbors[k]=k+1;
*num_Pts_s+=1;
/* increase number of neighbors */
}
}
}
void expandCluster(float EPS_CLUSTER1, int NMINPOINTS,int n,int *n_cluster,int *num_point_neighbors,int ind_p,float *traj_lon,float *traj_lat,float *vel_u,float *vel_v, int *indPts,int *cls)
{
 int jj,k1,num_Pts;
 float *p_s,*v_s;
 int *index_pts;
 int num_pts_in_cls;
 p_s= (float *) malloc(2 * sizeof(float));
 v_s= (float *) malloc(2 * sizeof(float));
 index_pts= (int *) malloc(n * sizeof(int));
*index_pts=0;
num_pts_in_cls=0;
while (*num_point_neighbors!=num_pts_in_cls){
*num_point_neighbors=num_pts_in_cls;
num_pts_in_cls=0;
 for (jj=0; jj<n;jj++) {
 if( (indPts[jj]>0) && (ind_p!=jj)){
 p_s[1]=traj_lon[indPts[jj]-1];
 p_s[2]=traj_lat[indPts[jj]-1];
 v_s[1]=vel_u[indPts[jj]-1];
 v_s[2]=vel_v[indPts[jj]-1];
num_Pts=0;
regionQuery(EPS_CLUSTER1,n,p_s,v_s,traj_lon,traj_lat,vel_u,vel_v,&num_Pts,indPts);}}
 for (k1=0;k1<n;k1++) {
 if (indPts[k1]>0){
 cls[indPts[k1]-1]=*n_cluster;
 num_pts_in_cls+=1;}}
/*printf("%4d\n",*num_point_neighbors);
printf("%4d\n",num_pts_in_cls);*/}
/* printf("%4d\n",num_Pts); */
}

void compute_cluster(float EPS_CLUSTER1,int NMINPOINTS,int n,int *num_clusters,int *num_points_Cl,float ind_lon, float ind_lat,float *final_lon, float *final_lat, float *velu,float *velv,int *clu)
/*subroutine computes number of clusters for given final distribution of drifters (positions are given in lat and long)
 n is number of drifters, num_clusters is number of clusters found, num_points_Cl is number of points in the cluster,
final_lon and final_lat are longitude and latitude of drifters,
cl is an array containing integer numbers (-1 if
drifter is noise, 0 if the cluster for it can not been defined, integer between 1-n if the drifter belong to cluster 1-n,
mean_traj_lat, mean_traj_lon are local variables for a given drifter lat and lon  */
{
float *p,*vv;
int *ind_neighborPts_s;
int i2,i3,num_neighborPts_s;
ind_neighborPts_s =  (int *) malloc(n * sizeof(int));
p =  (float *) malloc(2 * sizeof(float));
vv =  (float *) malloc(2 * sizeof(float));
*num_clusters=0;
for (i2=0;i2<n;i2++){
if (clu[i2]==0) {
for (i3=0;i3<n;i3++){
ind_neighborPts_s[i3]=0;}
p[1]=final_lon[i2];
p[2]=final_lat[i2];
vv[1]=velu[i2];
vv[2]=velv[i2];
num_neighborPts_s=0;
regionQuery(EPS_CLUSTER1,n,p,vv,final_lon,final_lat,velu,velv,&num_neighborPts_s,ind_neighborPts_s);
if (num_neighborPts_s<NMINPOINTS+1){
/*printf("%4d\n",num_neighborPts_s);*/
clu[i2]=-1;}
else
{*num_clusters+=1;
expandCluster(EPS_CLUSTER1,NMINPOINTS,n,num_clusters, &num_neighborPts_s,i2,final_lon,final_lat,velu,velv,ind_neighborPts_s,clu);
num_points_Cl[*num_clusters-1]=num_neighborPts_s;
printf("%4d\n",num_neighborPts_s);
}
}}}
void inter_time(int n, float weigth, float *uold, float *vold, float *unew, float *vnew, float *v_x, float *v_y)
{
/* uold, vold - are u and v current components of n particles at the previous time step;
 * unew, vnew - are u and v current components of n particles at the next time step;
 * v_x, v_y - are u and v current components of n particles interpolated between two time steps using linear interpolation weight */
int k;
for (k=0; k<n; k++){
v_x[k]=uold[k]+(unew[k]-uold[k])*(double)weigth;
v_y[k]=vold[k]+(vnew[k]-vold[k])*(double)weigth;
}
}
void bilin(int numt, int n,int dimx, int dimy,float *lon, float *lat,float coordx[dimx][dimy], float coordy[dimx][dimy], float ***ucnew, float ***vcnew, float *uc, float *vc)
{
/* bilinear interpolation to position of the particles of the velocities from the current field
 * dimX, dimY - are dimension of the current field
 * lon, lat - are longitudes and latitudes of n particles
 * coordx, coordy - are longitudinal and latitudinal nodes of the current field
 * ucnew, vcnew - are u and v components of velocity field
 * uc, v1 - are interpolated velocities of n particles */
int ii,k, jj;
float del;
del=sqrt((coordx[1][0]-coordx[0][0])*(coordy[0][0]-coordy[0][1])*(coordx[1][0]-coordx[0][0])*(coordy[0][0]-coordy[0][1]));
for (k=0; k<n; k++){
for (ii=0; ii<dimx-1; ii++){
for (jj=0; jj<dimy-1;jj++){
        if ((lat[k]<coordy[ii][jj+1])&&(lat[k]>=coordy[ii][jj])&&(lon[k]<coordx[ii+1][jj])&&(lon[k]>=coordx[ii][jj])){
          if (del!=0){
uc[k]=1/del*(ucnew[ii][jj][numt]*(coordx[ii+1][jj]-lon[k])*(coordy[ii][jj+1]-lat[k])+ucnew[ii+1][jj][numt]*(lon[k]-coordx[ii][jj])*(coordy[ii][jj+1]-lat[k]) \
+ucnew[ii][jj+1][numt]*(coordx[ii+1][jj]-lon[k])*(lat[k]-coordy[ii][jj])+ucnew[ii+1][jj+1][numt]*(lon[k]-coordx[ii][jj])*(lat[k]-coordy[ii][jj]));
vc[k]=1/del*(vcnew[ii][jj][numt]*(coordx[ii+1][jj]-lon[k])*(coordy[ii][jj+1]-lat[k])+vcnew[ii+1][jj][numt]*(lon[k]-coordx[ii][jj])*(coordy[ii][jj+1]-lat[k]) \
+vcnew[ii][jj+1][numt]*(coordx[ii+1][jj]-lon[k])*(lat[k]-coordy[ii][jj])+vcnew[ii+1][jj+1][numt]*(lon[k]-coordx[ii][jj])*(lat[k]-coordy[ii][jj]));
        }
}
if ((lat[k]>coordy[ii][jj+1])&&(lat[k]<=coordy[ii][jj])&&(lon[k]<coordx[ii+1][jj])&&(lon[k]>=coordx[ii][jj])){
          if (del!=0){
uc[k]=1/del*(ucnew[ii][jj][numt]*(coordx[ii+1][jj]-lon[k])*(coordy[ii][jj+1]-lat[k])+ucnew[ii+1][jj][numt]*(lon[k]-coordx[ii][jj])*(coordy[ii][jj+1]-lat[k]) \
+ucnew[ii][jj+1][numt]*(coordx[ii+1][jj]-lon[k])*(lat[k]-coordy[ii][jj])+ucnew[ii+1][jj+1][numt]*(lon[k]-coordx[ii][jj])*(lat[k]-coordy[ii][jj]));
vc[k]=1/del*(vcnew[ii][jj][numt]*(coordx[ii+1][jj]-lon[k])*(coordy[ii][jj+1]-lat[k])+vcnew[ii+1][jj][numt]*(lon[k]-coordx[ii][jj])*(coordy[ii][jj+1]-lat[k]) \
+vcnew[ii][jj+1][numt]*(coordx[ii+1][jj]-lon[k])*(lat[k]-coordy[ii][jj])+vcnew[ii+1][jj+1][numt]*(lon[k]-coordx[ii][jj])*(lat[k]-coordy[ii][jj]));
//printf("%g\t%g\n",uc[k],vc[k]);
        }
}
}
}
}
}
void swapfields(int numt,int dimx, int dimy, float ***ucold, float ***ucnew, float ***vcold, float ***vcnew)
{
/* dimX, dimY- are longitudinal and latitudinal dimensions of the model data
 * the procedure is implemented to exchage the field values */
int ii, jj;
float uu[dimx][dimx],vv[dimx][dimy];
for (ii=0; ii<dimx; ii++) {
for (jj=0; jj<dimy; jj++) {
 uu[ii][jj]=ucold[ii][jj][numt];
 ucold[ii][jj][numt]=ucnew[ii][jj][numt];
 ucnew[ii][jj][numt]=uu[ii][jj];
 vv[ii][jj]=vcold[ii][jj][numt];
 vcold[ii][jj][numt]=vcnew[ii][jj][numt];
 vcnew[ii][jj][numt]=vv[ii][jj];
}
}
}
